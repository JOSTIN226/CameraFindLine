
#include "includes.h"
const unsigned char font6x8[][6] =
{
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   // sp 0
    { 0x00, 0x00, 0x00, 0x2f, 0x00, 0x00 },   // !
    { 0x00, 0x00, 0x07, 0x00, 0x07, 0x00 },   // "
    { 0x00, 0x14, 0x7f, 0x14, 0x7f, 0x14 },   // #
    { 0x00, 0x24, 0x2a, 0x7f, 0x2a, 0x12 },   // $
    { 0x00, 0x62, 0x64, 0x08, 0x13, 0x23 },   // %
    { 0x00, 0x36, 0x49, 0x55, 0x22, 0x50 },   // &
    { 0x00, 0x00, 0x05, 0x03, 0x00, 0x00 },   // '
    { 0x00, 0x00, 0x1c, 0x22, 0x41, 0x00 },   // (
    { 0x00, 0x00, 0x41, 0x22, 0x1c, 0x00 },   // )
    { 0x00, 0x14, 0x08, 0x3E, 0x08, 0x14 },   // *  10
    { 0x00, 0x08, 0x08, 0x3E, 0x08, 0x08 },   // +
    { 0x00, 0x00, 0x00, 0xA0, 0x60, 0x00 },   // ,
    { 0x00, 0x08, 0x08, 0x08, 0x08, 0x08 },   // -
    { 0x00, 0x00, 0x60, 0x60, 0x00, 0x00 },   // .
    { 0x00, 0x20, 0x10, 0x08, 0x04, 0x02 },   // /
    { 0x00, 0x3E, 0x51, 0x49, 0x45, 0x3E },   // 0
    { 0x00, 0x00, 0x42, 0x7F, 0x40, 0x00 },   // 1
    { 0x00, 0x42, 0x61, 0x51, 0x49, 0x46 },   // 2
    { 0x00, 0x21, 0x41, 0x45, 0x4B, 0x31 },   // 3
    { 0x00, 0x18, 0x14, 0x12, 0x7F, 0x10 },   // 4  20
    { 0x00, 0x27, 0x45, 0x45, 0x45, 0x39 },   // 5
    { 0x00, 0x3C, 0x4A, 0x49, 0x49, 0x30 },   // 6
    { 0x00, 0x01, 0x71, 0x09, 0x05, 0x03 },   // 7
    { 0x00, 0x36, 0x49, 0x49, 0x49, 0x36 },   // 8
    { 0x00, 0x06, 0x49, 0x49, 0x29, 0x1E },   // 9
    { 0x00, 0x00, 0x36, 0x36, 0x00, 0x00 },   // :
    { 0x00, 0x00, 0x56, 0x36, 0x00, 0x00 },   // ;
    { 0x00, 0x08, 0x14, 0x22, 0x41, 0x00 },   // <
    { 0x00, 0x14, 0x14, 0x14, 0x14, 0x14 },   // =
    { 0x00, 0x00, 0x41, 0x22, 0x14, 0x08 },   // >  30
    { 0x00, 0x02, 0x01, 0x51, 0x09, 0x06 },   // ?
    { 0x00, 0x32, 0x49, 0x59, 0x51, 0x3E },   // @  
    { 0x00, 0x7C, 0x12, 0x11, 0x12, 0x7C },   // A  33
    { 0x00, 0x7F, 0x49, 0x49, 0x49, 0x36 },   // B
    { 0x00, 0x3E, 0x41, 0x41, 0x41, 0x22 },   // C
    { 0x00, 0x7F, 0x41, 0x41, 0x22, 0x1C },   // D
    { 0x00, 0x7F, 0x49, 0x49, 0x49, 0x41 },   // E
    { 0x00, 0x7F, 0x09, 0x09, 0x09, 0x01 },   // F
    { 0x00, 0x3E, 0x41, 0x49, 0x49, 0x7A },   // G   
    { 0x00, 0x7F, 0x08, 0x08, 0x08, 0x7F },   // H  40
    { 0x00, 0x00, 0x41, 0x7F, 0x41, 0x00 },   // I
    { 0x00, 0x20, 0x40, 0x41, 0x3F, 0x01 },   // J
    { 0x00, 0x7F, 0x08, 0x14, 0x22, 0x41 },   // K
    { 0x00, 0x7F, 0x40, 0x40, 0x40, 0x40 },   // L
    { 0x00, 0x7F, 0x02, 0x0C, 0x02, 0x7F },   // M
    { 0x00, 0x7F, 0x04, 0x08, 0x10, 0x7F },   // N
    { 0x00, 0x3E, 0x41, 0x41, 0x41, 0x3E },   // O
    { 0x00, 0x7F, 0x09, 0x09, 0x09, 0x06 },   // P
    { 0x00, 0x3E, 0x41, 0x51, 0x21, 0x5E },   // Q   
    { 0x00, 0x7F, 0x09, 0x19, 0x29, 0x46 },   // R  50
    { 0x00, 0x46, 0x49, 0x49, 0x49, 0x31 },   // S
    { 0x00, 0x01, 0x01, 0x7F, 0x01, 0x01 },   // T
    { 0x00, 0x3F, 0x40, 0x40, 0x40, 0x3F },   // U
    { 0x00, 0x1F, 0x20, 0x40, 0x20, 0x1F },   // V
    { 0x00, 0x3F, 0x40, 0x38, 0x40, 0x3F },   // W
    { 0x00, 0x63, 0x14, 0x08, 0x14, 0x63 },   // X
    { 0x00, 0x07, 0x08, 0x70, 0x08, 0x07 },   // Y
    { 0x00, 0x61, 0x51, 0x49, 0x45, 0x43 },   // Z
    { 0x00, 0x00, 0x7F, 0x41, 0x41, 0x00 },   // [   
    { 0x00, 0x55, 0x2A, 0x55, 0x2A, 0x55 },   // 55 60
    { 0x00, 0x00, 0x41, 0x41, 0x7F, 0x00 },   // ]
    { 0x00, 0x04, 0x02, 0x01, 0x02, 0x04 },   // ^
    { 0x00, 0x40, 0x40, 0x40, 0x40, 0x40 },   // _
    { 0x00, 0x00, 0x01, 0x02, 0x04, 0x00 },   // '
    { 0x00, 0x20, 0x54, 0x54, 0x54, 0x78 },   // a  65
    { 0x00, 0x7F, 0x48, 0x44, 0x44, 0x38 },   // b
    { 0x00, 0x38, 0x44, 0x44, 0x44, 0x20 },   // c
    { 0x00, 0x38, 0x44, 0x44, 0x48, 0x7F },   // d
    { 0x00, 0x38, 0x54, 0x54, 0x54, 0x18 },   // e
    { 0x00, 0x08, 0x7E, 0x09, 0x01, 0x02 },   // f  70
    { 0x00, 0x18, 0xA4, 0xA4, 0xA4, 0x7C },   // g
    { 0x00, 0x7F, 0x08, 0x04, 0x04, 0x78 },   // h
    { 0x00, 0x00, 0x44, 0x7D, 0x40, 0x00 },   // i
    { 0x00, 0x40, 0x80, 0x84, 0x7D, 0x00 },   // j
    { 0x00, 0x7F, 0x10, 0x28, 0x44, 0x00 },   // k
    { 0x00, 0x00, 0x41, 0x7F, 0x40, 0x00 },   // l
    { 0x00, 0x7C, 0x04, 0x18, 0x04, 0x78 },   // m
    { 0x00, 0x7C, 0x08, 0x04, 0x04, 0x78 },   // n
    { 0x00, 0x38, 0x44, 0x44, 0x44, 0x38 },   // o
    { 0x00, 0xFC, 0x24, 0x24, 0x24, 0x18 },   // p  80
    { 0x00, 0x18, 0x24, 0x24, 0x18, 0xFC },   // q
    { 0x00, 0x7C, 0x08, 0x04, 0x04, 0x08 },   // r
    { 0x00, 0x48, 0x54, 0x54, 0x54, 0x20 },   // s
    { 0x00, 0x04, 0x3F, 0x44, 0x40, 0x20 },   // t
    { 0x00, 0x3C, 0x40, 0x40, 0x20, 0x7C },   // u
    { 0x00, 0x1C, 0x20, 0x40, 0x20, 0x1C },   // v
    { 0x00, 0x3C, 0x40, 0x30, 0x40, 0x3C },   // w
    { 0x00, 0x44, 0x28, 0x10, 0x28, 0x44 },   // x
    { 0x00, 0x1C, 0xA0, 0xA0, 0xA0, 0x7C },   // y
    { 0x00, 0x44, 0x64, 0x54, 0x4C, 0x44 },   // z  90
    { 0x14, 0x14, 0x14, 0x14, 0x14, 0x14 }    // horiz lines
};


void Delay_us(unsigned int ut)
{
  unsigned int ux,uy;
  for(ux=0;ux<=8;ux++) 
     for(uy=ut;uy>0;uy--){}
}

void Delay(unsigned int ut)
{
	unsigned int ux,uy;
    for(ux=0;ux<5000;ux++) 
       for(uy=ut;uy>0;uy--){}
}
/**********************************************************************
* 函数名称：LCD_init()		
* 函数功能：初始化nokia5110
* 入口参数：无
* 出口参数：无
* 修改人  ：BDC
* 修改时间：2011/08/04
**********************************************************************/
void LCD_Init(void)
  {           
    LCD_RST = 0; // 产生一个让LCD复位的低电平脉冲
    Delay_us(1);
    LCD_RST = 1;
    LCD_CE = 0;// 关闭LCD  
    Delay_us(1);		
    LCD_CE = 1;// 使能LCD
    Delay_us(1);
    LCD_write_byte(0x21, 0);	// 使用扩展命令设置LCD模式
    LCD_write_byte(0xc8, 0);	// 设置偏置电压
    LCD_write_byte(0x06, 0);	// 温度校正
    LCD_write_byte(0x13, 0);	// 1:48
    LCD_write_byte(0x20, 0);	// 使用基本命令
    LCD_clear();	            // 清屏
    LCD_write_byte(0x0c, 0);	// 设定显示模式，正常显示        
    LCD_CE = 0;                 // 关闭LCD  
}
 /**********************************************************************
* 函数名称：LCD_clear()		
* 函数功能：液晶清屏
* 入口参数：无
* 出口参数：无
* 修改人  ：BDC
* 修改时间：2011/08/04
**********************************************************************/
void LCD_clear(void)
{
	unsigned int i;
	LCD_write_byte(0x0c, 0);			
	LCD_write_byte(0x80, 0);	
	for (i=0; i<504; i++)
	  LCD_write_byte(0, 1);			
}
/**********************************************************************
* 函数名称：LCD_write_byte()
* 函数功能：写一个字节
* 入口参数：data,要写入的字节;command:0为命令,1为数据
* 出口参数：无
* 修改人  ：BDC
* 修改时间：2011/08/04
***********************************************************************/
void LCD_write_byte(unsigned char data, unsigned char command)
{
  unsigned char i;    
  LCD_CE = 0;    
  if (command == 0)     
 	 LCD_DC = 0;
  else    
  	LCD_DC = 1;
  for(i=0;i<8;i++)
	{
		if(data&0x80)
			SDIN = 1;
		else
			SDIN = 0;
		SCLK = 0;
		data= data<< 1;
		SCLK = 1;
	}   
   LCD_CE = 1;
}

/**********************************************************************
* 函数名称：LCD_set_XY()
* 函数功能：光标定位x行y列
* 入口参数：X,Y   x行y列
* 出口参数：无
* 修改人  ：BDC
* 修改时间：2011/08/04
**********************************************************************/
void LCD_set_XY(unsigned char X, unsigned char Y)
  {
    LCD_write_byte(0x40 | Y, 0);		// column
    LCD_write_byte(0x80 | X, 0);        // row
  }
 
/***********************************************************************
* 函数名称：LCD_write_char()
* 函数功能：写入1个字符
* 入口参数：c   要写入的数据
* 出口参数：无
* 修改人  ：BDC
* 修改时间：2011/08/04
**********************************************************************/
void LCD_write_char(unsigned char c)
  {
    unsigned char line;
    c -= 32;
    for (line=0; line<6; line++)
      LCD_write_byte(font6x8[c][line], 1);//从ACSII码表中读取字节，然后写入液晶
  }

/***********************************************************************
* 函数名称：LCD_Write_Num()
* 函数功能：显示变亮
* 入口参数：X:行;Y:列;num:变量;N:要显示的变量的位数
* 出口参数：无
* 修改人  ：BDC
* 修改时间：2011/08/04
/**********************************************************************/
void LCD_Write_Num(unsigned char X,unsigned char Y,unsigned int num,unsigned char N)
{
  unsigned char line;
  unsigned char i=0;
  unsigned int n[5]={0};
  n[0]= num%10;
  n[1]=(num/10)%10;
  n[2]=(num/100)%10;
  n[3]=(num/1000)%10;
  n[4]=(num/10000)%10;
  for(i=0;i<5;i++) n[i]=n[i]+16;
  for(i=N;i>0;i--) 
  {
    LCD_set_XY(X+(N-i)*6,Y);//光标定位
    for (line=0; line<6; line++)
      LCD_write_byte(font6x8[n[i-1]][line], 1);//从ACSII码表中读取字节，然后写入液晶
  }
}

/***********************************************************************
* 函数名称LLCD_write_english_string()
* 函数功能：写英文字符串
* 入口参数：X,Y,*S------x行y列*s为英文字符串
* 出口参数：无
* 修改人  ：BDC
* 修改时间：2011/08/04
***********************************************************************/
void LCD_write_english_string(unsigned char X,unsigned char Y,char *s)
{
	LCD_set_XY(X,Y);//光标定位
	while (*s) 
	{
		 LCD_write_char(*s);
		 s++;
	}
}



//***********************************************************************************************************
//***********************************************************************************************************
//*			***********************************自编函数**************************************************   *
//***********************************************************************************************************
//***********************************************************************************************************


/****************************************************************************************************************
* 函数名称：LCD_Show()		
* 函数功能：刷完整图像或三条线(依据不同模式选择)
* 入口参数：无
* 出口参数：无
* 修改人  ：徐博
* 修改时间：2013/08/11
*****************************************************************************************************************/
void LCD_Show()
{
	Video_Show();
	
	if(mode==8)//图像对中
	{
		LCD_write_english_string(0,5,"DeTime");
		LCD_set_XY(41,5);
		LCD_write_byte(0xFF,1);
		LCD_Write_Num(48,5,RowSAIC_DelayTime,3);		//左线终点
		ChangeVideoDelayTime();
	}
	else if(mode==9)//图像+中线+target_offset+舵机输出 
	{
		LCD_write_english_string(0,5,"T");
		if(target_offset<0) LCD_write_english_string(6,5,"-");
		else LCD_write_english_string(6,5,"+");
	    LCD_Write_Num(12,5,ABS(target_offset),2);
	    
	   	if(Steer_PWM[3]<CENTER) LCD_write_english_string(24,5,"-");
	   	else LCD_write_english_string(24,5,"+");
	    LCD_Write_Num(30,5,ABS((signed int)Steer_PWM[3]-(signed int)CENTER),3);  
	    
	    LCD_Write_Num(70,5,RoadType,2);
	}
	else if(mode==10)//图像+中线+赛道类型及参数
	{
		LCD_Write_Num(0,5,EndRow[0],2);		//左线终点
		LCD_Write_Num(18,5,StartRow[0],2);	//左线起点
		LCD_Write_Num(36,5,RoadType,1);		//赛道类型
		LCD_Write_Num(48,5,StartRow[1],2);	//右线起点
		LCD_Write_Num(66,5,EndRow[1],2);	//右线终点
	}
	else if(mode==11)//三条线及参数{}
	{}
	else if(mode==12)
	{
		 LCD_Write_Num(0,5,RoadType,2);
		 LCD_Write_Num(18,5,turn[0],2);
		 LCD_Write_Num(36,5,turn[1],2);
		 LCD_Write_Num(54,5,turn[2],2);
	}
}

/****************************************************************************************************************
* 函数名称：Video_Show()		
* 函数功能：刷图像不带最后一行参数显示
* 入口参数：无
* 出口参数：无
* 修改人  ：徐博
* 修改时间：2013/08/11
*****************************************************************************************************************/
void  Video_Show()
{
	unsigned char _byte=0;
	unsigned char _bit=0;
	unsigned char _column=0;
	unsigned char _char;
	LCD_set_XY(0,0);
	//刷前3组,46行,隔行取
	for(_byte=0;_byte<3;_byte++)
	{
		for(_column=0;_column<COLUMNS;_column++)
		{
			_char=0;
			for(_bit=0;_bit<8;_bit++)
			{
				_char=_char>>1;
				if(pix[_byte*16+_bit*2][_column])
					_char|=0x80;
			}
			LCD_write_byte(_char,1);
		}
		LCD_write_byte(0x00,1);
	}
	//刷第4组,48\49\51\52\54\55\57\58
	for(_column=0;_column<COLUMNS;_column++)
	{
			_char=0;
			for(_bit=0;_bit<8;_bit++)
			{
				_char=_char>>1;
				if(pix[48+_bit*3/2][_column])
					_char|=0x80;
			}
			LCD_write_byte(_char,1);
	}
    	LCD_write_byte(0x00,1);
   //刷第5组,62-69
	for(_column=0;_column<COLUMNS;_column++)
	{
		_char=0;
		for(_bit=0;_bit<8;_bit++)
		{
			_char=_char>>1;
			if(pix[62+_bit][_column])
				_char|=0x80;
		}
		LCD_write_byte(_char,1);
	}
}

/****************************************************************************************************************
* 函数名称：void ThreeLineNoVideo(void)		
* 函数功能：得到三条线图像
* 入口参数：无
* 出口参数：无
* 修改人  ：徐博
* 修改时间：2013/08/11
*****************************************************************************************************************/
void ThreeLineNoVideo()
{
	byte i,j;
	for(i=0;i<ROWS;++i)
			for(j=0;j<COLUMNS;++j)
				pix[i][j]=0;
	for(i=RoadEnd;i<=RoadStart;++i)
		pix[i][CenterLine[i]]=1;
	for(i=EndRow[0];i<=StartRow[0];++i)
		pix[i][BlackLine[0][i]]=1;
	for(i=EndRow[1];i<=StartRow[1];++i)
		pix[i][BlackLine[1][i]]=1;
}

/****************************************************************************************************************
* 函数名称：void CenterLineWithVideo(void)		
* 函数功能：得到图像和中线
* 入口参数：无
* 出口参数：无
* 修改人  ：徐博
* 修改时间：2013/08/11
*****************************************************************************************************************/
void CenterLineWithVideo()
{
	byte i,j;
	for(i=0;i<ROWS;++i)
		for(j=0;j<COLUMNS;++j)
			pix[i][j]=(1-g_pix[i][j]);
	for(i=RoadEnd;i<=RoadStart;++i)
			pix[i][CenterLine[i]]=1;	
}